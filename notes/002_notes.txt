-- primitive types
in java types are the most basic data types. The in is one of eight primitive types.
The eight primitive data types in java are boolean, byte, char, short, int, long, float and double.
Consider these types as the building blocks of data mnipulation.

-- Java packages
A package is a way to organize your java projects. For now, consider them as folders with learnprogramming in our example being a subfolder of acadey. Companies use their domain names reversed.
So learnprogramming.academy becomes academy.learnprogramming.

-- Wrapper classes
Java uses the concept of a wrapper class for all eight primitive types - in te case of an int, we can use Integer, and by doing that it gives us ways to perform operations on an int.
int myMinIntValue = Integer.MIN_VALUE;
int myMaxIntValue = Integer.MAX_VALUE;
System.out.println("Integer Minimun Value = " + myMinIntValue);
System.out.println("Integer Maximun value = " + myMaxIntValue);
In this case, we are using the MIN_VALUE and MAX_VALUE to get java to tell us the minimum and maximum ranges of numbers that can be stored.

-- overflow and underflow in java
if you try and put a value larger than the maximum value in java, or a value smaller than the minimum value in java, then you will get an Overflow in the case of the maximum value aor an Underflow in the case of the minimum.

The computer just kips back to the minimum number or the maximum number, which is usually not what you want. It's an important concept to be aware of.

-- size of primitive types and width
A byte occupies 8 bits. A bit is not directly represented in a priitive type - we hava boolean which is not really the same thing. So a byte occupies 8 bits. We say that a byte has a width of 8.

A short can store a large range of numbers and occupies 16 bits, and has a width of 16.

An int, has a much larger range as we know and occupiets 32 bits, and has a width of 32.

The point here is that each primitive type occupies a different amount of memory - we can see that an int needs four times the amount of space, than a byte does for example.

-- casting in java
Casting meanns to treat or convert a number from on type to another. We put the type we want the number to be in parenthesis like this:
(bye) (myIntByteValue / 2)

-- floating point numbers
unlike whole numbers, floating point numbers have fractional parts that were express with a decimal point. 3.14159 is an example.
Floating point numbers are also known as real numbers. We use a floating point number when we need more precision in calculations.

-- single and double precision
precision refers to the format and amount of space occupied by the type. Single precision occupies 32 bits (so has a width of 32) and a Double precision occupies 64 bits (and thus has a width of 64)

As a result the float has a range from 1.4E-45 to 3.4028235E+38 and the double is much more precise with a range from 4.9E-324 to 17976931348623157E+308.

-- floating point number precision tips
in general float and double are great for general floating point operations. But both are not great to use where precise calculations are required - this is due to a limitation with how floating point numbers are stored, and not a java problem as such.

Java has a class called BigDecimal that overcomes this. When precise calculations are necessary, such as when performing currency calculations, floating-point types should not be used.

But for general calculations float and double are fine.

-- Char data type
A char occupies two bytes of memory, or 16 bits and thus has a width of 16. The reason it's not just a single byte is that it allows you to store Unicode characters.

-- Unicode
Unicode is an international encodign standar for use with different languages and scripts, by which each letter, digit, or symbol is assigned a unique numeric value that applies accross different platforms and programs.

In the English alphabet, we have the letters A through Z. Meaning only 26 characters are needed in total to represent the entire English alphabet. But other languages need more characters, and often a lot more.


Unicode allows us to reprsent these languages and the way it works is that by using a combination of the two bytes that a char takes up in memory it can represent and one of 65535 different types of characters.

-- Boolean primitive type
A boolean value allows for two choices True or Flase, Yes or No, 1 or 0. In Java terms we have a boolean primitive type and it can be set to two values only, true or false. They are actually pretty useful and you will use them a lot when programming.

-- String
The String is a datatype in Java, which is not a primitive type. It's actually a Class, but it enjoys a bit of favoritism in Java to make it easier to use than a regular class.

-- What is a String?

A String is a sequence of characters. In the case of the char a single character only (regular character or Unicode character).

A String can contain a sequence of characters. A large number of characaters. Technically it's limited by memory of the MAX_VALUE of an int which was 2.14 Billion.

-- Strings in Java are immutable
When I said you can delete characters out of String, tat's not stricly true. Because Strings in Java are immutable. That means you can't change a String after it's created. Instead, what happens is a new String is created.

-- The code we used to append Strings was inefficient
As a result of a String being created, appending values like this is inefficient and not recommended. A better way of doing it is used something called a StringBuffer which can be changed.

We need an understanding of classes before we tackle StringBuffer, and also, you will come across code written in the style I've used in this lecture so it's still useful for you to know how to do things this way.

-- what are operators?
Operators in Java are special symbols that perform specific operations on one, two, or three operands, and then return a result. As an example, we used the + (addition) operator to sum the value of two variables.
There are many operands in Java.

-- what is an operand?
An operand is a term used to describe any object that is manipulated by an oprator. If we consider this statement.
int myVar = 15 + 12;
Then + is the operator, and 15 and 12 are the operands. Variables used instead of literals are also operands.
double mySalaray = hoursWorked * hourlyRate;
In the above line hoursWorked and hourlyRate are operands, and * (multiplication) is the operator.

-- what is an Expression?
An expression is formed by combining variables, literals, method return values (which we haven't covered yet) and operators.

in the line below, 15 + 12 is the expression which has (or returns) 27 in this case.
int myValue = 15 + 12;

in the statement below, hoursWorked * hourlyRate is the expression. If hourseWorked was 10.00 and hourlyRate was 20.00 then the expression would return 200.00;
double mySalary = hoursWorked * hourlyRate;

-- What is a comment?
Comments are ignored by the computer and are added to a program to help describe something. Comments are there for humans.

We use // in front of any code, or on a blank line. Anything after the // right through to the end of the line is ignored by the computer.

Aside from describing something about a program, comments can be used to temporarily disable code.

-- if-then Statements in Java
The if-then statement is the most basic of all the control flow statements. It tells your program to execute a certain section of code only if a particular test evaluates to true.

This is known as conditional logic.

-- Conditional Logic
Conditional logic uses specific statements in Java to allow us to check a condition and execute certain code based on whether that condition (the expression) is true or false.

-- if-then RUle - Always use a code block
instead of using the if-statement as we can see here, we should instead use a code block.
A code block allows more than one statement to be executed - a block of code.
if (expression) {
    // put one or more statements here
}

-- logical AND and logical or
the AND operator comes in two flavors in Java, as does the OR operator.
&& is the logical AND which operates on boolean operands - Checking if a given condition is true or false.

you will almost always wanat to be doing this. The & is a bitwise operator working at the bit level.

Likewise || is the logical OR what again operates on boolean operands - Checking if a given condition is true or false.

Again, you will almost always want to be doing this. The | is a bitwise operator working at the bit level.

-- difference between the assignment and Equal to operators
int newValue = 50;
if (newValue = 50) {
    System.out.println("This is an error");
}
As you can see in the code we typed to declare the newValue int, it's using the assignment operator (one equal sign) to assign the value 50 to new value.
What we needed to do in the code is to not use the assigment operator in the if-then statement, but rather the equal to operator which has two equal signs.
if (newValue == 50) {
    System.out.println("This is an error");
}

-- the NOT operator
The ! or NOT operator is also known as the Logical complement operator.
For use with booleans it tests the alternate value - we saw (isCar) test for true, by adding a ! operator before the value we can check the opposite - false in this case.

boolean isCar = false;
We can use either of these statements:
if (isCar == false)
if (!isCar)
to check if the boolean isCar is false.

it's generally recommended to use the abbreviated form of both for two reason. One to avoid the potential for error by accidentally using an assignment operator, and second the code is more concise.

-- ternary operatord ?:
int ageOfClient = 20;
boolean isEighteenOrOver = ageOfClient == 20 ? true : false;
Operand one - ageOfClient == 20 in this case is the condition we are checking. It needs to return true or false.
Operand two - true here is the valu to assign to the variable isEighteenOrOver if the condition above is true.
In this case, isEighteenOrOver is assigned the value true because ageOfClient has the value 20.

-- method overloading
Method overloading is a feature that allows a class to have more than one method having the same name if their argument lists are different.
it is the ability to create multiple methods of the same name with different implementations.
calls to an oveloaded method will run a specific implementation of that method
it improves code readability and re-usability.
it is easier to remember one method name instead of remembering multiple names.
Achieves consistency in naming. One name for methods that are commonly used for example println.
Overloaded methods give programmers the flexibility to call a similar method with different types of data.

-- format a number
String.format("%.2f", 700.000000001); -> 700.00

-- the for statement
for (init; condition, increment) {
    // statements
}

-- the shile loop
while (condition) {
    // statements
}

-- the do while loop
do {
    // statements
} while (condition);

-- parsing values fro a String
String numberAsString = "2020";
System.out.println("numberAsString = " + numberAsString);

int number = Integer.parseInt(numberAsString);

-- reading user input
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter your year of birth: ");
        boolean hasNextInt = scanner.hasNextInt();

        if (hasNextInt) {
            int yearOfBirth = scanner.nextInt();
            scanner.nextLine(); // handle next line character (enter key)
            System.out.println("Enter your name: ");
            String name = scanner.nextLine();
            int age = 2020 - yearOfBirth;

            if (age >= 0 && age <= 100) {
                System.out.println("Your name is " + name + ", and you are " + age + " years old");
            } else {
                System.out.println("Invalid year of birth.");
            }
        } else {
            System.out.println("Unable to parse year of birth");
        }

        scanner.close();
    }
}

-- Reference vs Object vs Instance vs Class
You probably noticed words like reference, object, instance and class in this section.
These new concepts might be confusing at first. In this video you will find out exactly what each one of
those words mean in the context of Java programming.

Let's use the analogy of building a house to understand classes
A class is basically a blueprint for a house, using the blueprint (plans) we can build as
many house as we liked based on those plans.

Each house you build (in other words instantiate using the new operator) is an object
also known as an instance.

Each house you build has an address (a physical location). In other words if you want to
tell someone where you live, you give them your address (perhaps written in a piece of
paper). This is known as a reference.

You can copy that reference as many times as you like but their is still just one house. In
other words we are copying the paper that has address on it not the house itself.

We can pass references as parameters to constructors and methods

-- this vs super
let's discuss the difference between the this and the super keywords

we'll also find out about the differences between this() and super() method calls

let's discuss the super and the this keywords first

the keyword super is used to access/call the parent class members (variables and methods)

the keyword this is used to call the current class members (variables and methods). This
is required when we have a parameter with the same name as an instance variable (field).

note: we can use both of them anywhere in the class except static areas (the static block
or a static method). Any attempt to do so will lead to compile-time errors (more on static
later in the course)

-- keyword this
The keyword this is commonly used with constructors and setters, and optionally in getters (easier for
begginers). In the example below we are using the this keyword in the constructor and setter since
there is a parameter with the same name. In the getter we don't have any parameters so the this
keyword is optional.
... start
class House {
    private String color;

    public House(String color) {
        // this keyword is required, same parameter name as field
        this.color = color;
    }

    public STring getColor() {
        // this is optional
        return color; // same as return this.color;
    }

    public void setColor(String color) {
        // this keyword is required, same parameter names as field
        this.color = color;
    }
}
... end

-- keyword super
The keyword super is commonly used with method overriding, when we call a method
with the same name from the parent class. In the example below we have a method
printMethod that calls super.printMethod.

In other words it's calling the method with the same name from the parent class. Without the keyword
super in this case it would be recursive call. Meaning that the method would call it self forever (or until
memory is fully used). That is why the super keyword is needed.
... start
class SuperClass { // parent class aka super class
    public void printMethod() {
        System.out.println("Printed in Superclass.");
    }
}

class SubClass extends SuperClass {
    // overrides method from parent
    @Override
    public void printMethod() {
        super.printMethod(); // calls method in SuperClass (parent)
        System.out.println("Printed in Subclass");
    }
}

class MainClass {
    public static void main(String[] args) {
        SubClass s = new SubClass();
        s.printMethod();
    }
}
... end

-- this() vs super() call
In java we have the this() call and the super() call. NOtice the braces it is known as a call
since it looks like a regular method call.

Use this() to call a constructor from another overloaded constructor in the same class.
The call to this() can be used only in a constructor, and it must be the first statement in a
constructor. It's used with constructor chaining, in other words when one constructor
calls another constructor, and helps to reduce duplicated code.

The only way to call a parent constructor is by calling super(). This calls the parent
constructor.

The Java compiler puts a default call to super() if we don't add it, and it is always the no-args
super which is inserted by compiler (constructor without arguments).

The call to super() must be the first statement in each constructor.

Event Abstract classes have constructors, although you can never instatiate an
Abstract class using the new keyword.

An abstract class is still a super calss, so its constructors run when someone makes an
instace of a concrete subclass.

NOTE: a constructor can hava a call to super() or this() but never both.

-- super() call example
In this example we have a class Shape with x, y variables and class Rectangle
that exptends SHape with variables width and height.

In Rectangle, the 1st constructor we are calling the 2nd constructor

The 2nd constructor calls the parent constructor with parameters x and y

The parent constructor will initialize x,y variables while the 2nd Rectangle constructor
will initialize the width and height variables.

Here we have both super() and this() calls
... start
class Shape {
    private int x;
    private int y;

    public Shape(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class Rectangle extends Shape {
    private int width;
    private int height;

    // 1st constructor
    public Rectangle(int x, int y) {
        this(x, y, 0, 0); // calls 2nd constructor
    }

    // 2nd constructor
    public Rectangle(int x, int y, int width, int height) {
        super(x, y); // calls constructor from parent (Shape)
        this.width = width;
        this.height = height;
    }
}
... end

-- Method overloading
Method overloading means providing two or more separate methods in a class with
the same name but different parameters.

Method return tupe may or may not be different and that allows us to reuse the same
method name.

Overloading is very handy, it reduces duplicated code and we don't have to remember
multiple method names.

Overloading does not have anything to do with polymorphism but Java developers
ofther refer to overlaoding as Compile Time Polymorphism.

In other words the compiler decided which method is going to be called based on the
method name, return type and argument list.

We can overload static and instance methods.

Usually overloading happens inside a single class, but a method can also be treated as
overloaded in the subclass of that class.

That is because a subclass inherits one version of the method from the parent class
and then the subclass can have another overloaded version of the method.

-- method overloading rules
- methods will be considered overloaded if both follow the following rules
    - methods must have the same method names
    - methods must have different parameters
- if methods follow the rules above then the may or may not
    - have different return type.
    - have different access modifiers.
    - Throw different checked or unchecked exceptions.

-- Method Overriding
Method overriding means defining a method in a child class that already exists in the
parent class with the same signature (same name, same arguments)

By extending the parent class the child class gets all the methods defined in the parent
class (those mehods are also known as derived methods).

Method overriding is also known as Runtime Polymorphism and Dynamic Method Dispatch,
because the method that is going to be called is decided at runtime by the JVM.

Whe we override a method it's recommended to put @Override immediately above
the method definition. This is an annotation that the compiler reads and will then
show us an error if we don't follow overriding rules correctly.

We can't override static methods only instance methods.

-- method overriding rules
Method will be considered overridden if we follow these rules
    - it must have same name and arguments
    - Return type ca be a subclass of the return type in the parent class.
    - it can't ave a lower access modifier.
    - For example, if the parent method is protected the using private in the child is not
    allowed but using public in the child would be allowed.

There are also some important points about method overriding to keep in mind
    - only inherited methods can be Overridden, in other words methods can be
    overridden only in child classes.
    - Constructor and private methods cannot be overridden.
    - Methods that are final cannot be overriden.
    - A subclass can use super.methodName() to call the superclass version of an
    overriden method.

... start
class Dog {

    public void bark() {
        System.out.println("woof");
    }
}

class GermanShepherd extends Dog {

    @Override
    public void bark() {
        System.out.println("woof woof woof");
    }
}
... end

-- Static vs Instance methods

-- static methods

Static methods are declared using a static modifier.

Static methods can't access instance methods and instance variables directly.

They are usually used for operations that don't require any data from an instance of
the class (from 'this')

If you remember, the this keyword is the current instance of a class.

In static methods we can't use the this keyword.

Whenever you see a method that does not use instance variables that method
should be declared as a static method.

For example main is a static method and it is caslled by the JVM when it start an
application.

-- instance methods
Instance methods belong to an instance of a class.

To use an instance method we have to instanctiate the class first usually by using
the new keyword.

Instance methods can access instance methods and instance variables directly.

Instance methods can also access static methods and static varaibles directly.

-- static or instance method

- should a method be static?
    - does it use any fields (instance variables or instance methods?)
    - Yes
        - it should probably be an instance method
    - No
        - it should probably be a static method

-- static vs instance variables

-- static variables
declared by using the keyword static

static variables are also known as static member variables

every instance of that class shares the same static variable

if changes are made to that variable, all other instances will see the effect of the change.

static variables are not used very often but can sometimes be very useful

for example, when reading user input using Scanner we will declare scanner as a static variable.

That way static methods can access it directly.

... start
class Dog {
    private static String name;

    public Dog(String name) {
        Dog.name = name;
    }

    public void printName() {
        System.out.println("name= " + name);
    }
}


public clas Main {
    public static void main(String[] args) {
        Dog rex = new Dog("rex"); // create instance (rex)
        Dog fluffy = new Dog("fluffy); // create instance (fluffy)
        rex.printName(); // prints fluffy
        fluffy.printName(); // prints fluffy
    }
}
... end

-- instance variables
the don't use the static keyword

instance variables are also kwnon as fields or member variables

instance variables belong to an instance of a class

every instance has it's own copy of an instance variable

every instance can have a different value (state)

instance variables represent the state of an instance

... start
class Dog {
    private String name;

    public Dog(String name) {
        this.name = name;
    }

    public void printName() {
        System.out.println("name= " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog rex = new Dog("rex"); // create instance (rex)
        Dog fluffy = new Dog("fluffy"); // create instance (fluffy)
        rex.printName(); // prints rex
        fluffy.printName(); // prints fluffy
    } // prints rex
    fluffy // prints fluffy
}
... end

-- Arrays
An array is a data structure that allows you to store multiple values of the same type
into a single variable

The default values of numeric array elements are set to zero

Arrays are zero indexed: an array with n elements is indexed from 0 to n - 1,
for example 10 elements index range is from 0 to 9.

If we try to access index that is out of range Java will give us an
ArrayINdexOutOfBoundsException, which idicates that the index is out of range in
other words out of bounds.

To access array elements we use the square braces [ and ], also known as array access operator.

Example of creating a new array:
... start
int[] array = new int[5];
... end

This array contains the elements from array[0] to array[4]

it has 5 elements and index 0 range from 0 to 4.

The new operator or keywaord is used to create the array and initialize the array
elements to their defaul values.

in this example, all the array elements are initialized to zero since this is an int array.

For boolean array element they would be initialized to false.

For string or other objects that would be null.

... start
int[] myNumbers = { 5, 4, 3, 2, 1 };
... end

we can also initialize an array inline by using array initializer block { and }. Values we
defined need to be separated by a comma.

this way of initializing an array is also known as an anonymous array.

it has 5 elements and index range 0 to 4

in this example, array elements are initialized to 5, 4, 3, 2, 1.

-- references types vs values types

-- array list
clone an array list
... start
ArrayList<String> arrayList = new ArrayList<>();
arrayList.addAll(groceryList.getGroceryList());

ArrayList<String> arrayList1 = new ArrayList<>(groceryList.getGroceryList());

// turn arraylist to array
String[] strings = new String(groceryList.getGroceryList().size());
strings = groceryList.getGroceryList().toArray(strings);
... end

-- autoboxing
autoboxing is when we convert a primitive value into its class object
unboxing is when we unwrap the value from a class to a primitive value
... start
ArrayList<Integer> integerArrayList = new ArrayList<>();
integerArrayList.add(Intgeger.valueOf(54)); // autoboxing
int value = integerArrayList.get(0).intValue(); // 54 -> unboxing

Integer myIntValue = 56; // Integer.valueOf(56);
int myInt = myIntValue; // Integer.intValue();
... end

-- LinkedList
... start
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Scanner;

public class Demo {

    public static void main(String[] args) {
        LinkedList<String> places = new LinkedList<>();
        addInOrder(places, "Sydney");
        addInOrder(places, "Melbourne");
        addInOrder(places, "Brisbane");
        addInOrder(places, "Perth");
        addInOrder(places, "Canberra");
        addInOrder(places, "Adelaide");
        addInOrder(places, "Darwin");
        printList(places);

        addInOrder(places, "Alice Springs");
        addInOrder(places, "Darwin");
        printList(places);

        visit(places);

//        places.add("Sydney");
//        places.add("Melbourne");
//        places.add("Brisbane");
//        places.add("Perth");
//        places.add("Canberra");
//        places.add("Adelaide");
//        places.add("Darwin");

//        printList(places);
//        printListFor(places);

//        places.add(1, "Alice Springs");
//        printList(places);
//
//        places.remove(4);
//        printList(places);
    }

    private static void printList(LinkedList<String> linkedList) {
        Iterator<String> i = linkedList.iterator();
        while (i.hasNext()) {
            System.out.println("Now visiting " + i.next());
        }
        System.out.println("====================");
    }

    private static void printListFor(LinkedList<String> linkedList) {
        for (int i = 0; i < linkedList.size(); i++) {
            System.out.println("Now visiting " + linkedList.get(i));
        }
        System.out.println("====================");
    }

    private static boolean addInOrder(LinkedList<String> linkedList, String city) {
        ListIterator<String> stringListIterator = linkedList.listIterator();

        while (stringListIterator.hasNext()) {
            int comparison = stringListIterator.next().compareTo(city);
            if (comparison == 0) {
                // equal, do not add
                System.out.println(city + " is already included as a destination");
                return false;
            } else if (comparison > 0) {
                // new city should appear before this one
                // Brisbane -> Adelaide
                stringListIterator.previous();
                stringListIterator.add(city);
                return true;
            } else if (comparison < 0) {
                // move on next city
            }
        }

        stringListIterator.add(city);
        return true;
    }

    private static void visit(LinkedList<String> cities) {
        Scanner scanner = new Scanner(System.in);
        boolean exit = false;
        boolean goingForward = true;
        ListIterator<String> listIterator = cities.listIterator();

        if (cities.getFirst().isEmpty()) {
            System.out.println("No cities in the itinerary");
            return;
        }

        System.out.println("now Visiting " + listIterator.next());
        printMenu();

        while (!exit) {
            int action = scanner.nextInt();
            scanner.nextLine();

            switch (action) {
                case 0:
                    System.out.println("Holiday (vacation) over.");
                    exit = true;
                    break;
                case 1:
                    if (!goingForward) {
                        if (listIterator.hasNext()) {
                            listIterator.next();
                        }
                        goingForward = true;
                    }
                    if (listIterator.hasNext()) {
                        System.out.println("Now visiting " + listIterator.next() + ".");
                    } else {
                        System.out.println("Reached the end of the list.");
                        goingForward = false;
                    }
                    break;
                case 2:
                    if (goingForward) {
                        if (listIterator.hasPrevious()) {
                            listIterator.previous();
                        }
                        goingForward = false;
                    }
                    if (listIterator.hasPrevious()) {
                        System.out.println("Now visiting " + listIterator.previous() + ".");
                    } else {
                        System.out.println("We are at the start of the list.");
                        goingForward = true;
                    }
                    break;
                case 3:
                    printMenu();
                    break;
                default:
                    break;
            }
        }
    }

    private static void printMenu() {
        System.out.println("Available actions:\npress ");
        System.out.println("0 - to quit\n" +
                "1 - go to next city\n" +
                "2 - go to previous city\n" +
                "3 - print menu options"
        );
    }
}
... end

-- foreach
... start
    ArrayList<Song> songs = new ArrayList<>();
    songs.add("song name");

    for (Song song : songs) {
        // statements ...
    }
... end

-- inner classes
access a inner class
... start
Gearbox mcLaren = new Gearbox(6);
Gearbox.Gear first = mcLaren.new Gear(1, 12.3);
System.out.println(first.driveSpeed(1000));
... end

-- Abstract class vs an interface
Let's discuss the main differences between an Abstract class and an interface
and when to use either of them

-- Abstract class
Abstract class are similar to interfaces. You cannot instantiate them, and they may
contain a mix of methods declared with or without an implementation.

however, with Abstract classes, you can declare fields that are not static and final, and
define public, protected, and private concrete methods.

An Abstract calss can extend only one parent class but it can implement multiple interfaces.

When an Abstract class is subclassed, the subclass usually provides implementatios for
all of the abstract methods in its parent class.

However, if it does not, then the subclass must also be declared abstract.

- Use an Abstract class when...
You want to share code among several closely related classes (Animal - with fields name, age...)

You expect classes that extend your Absrtact class to have many common methods or
fields or required access modifiers other than public (protected, private)

You want to declare non static or non final fields (for example name, age), this enables
you to define methods that can access and modify the state of an object (getName, setName)

When you have a requirement for your base class to provide a default implementation of
certain methods but other methods should be open to being overridden by child classes.

summary: The purpose of an Abstract class is to provide a common definition of a base
class that multiple derived classes can share.

- Interface
An interface is just the declaration of methods of a Class, it's not the implementation.

In an interface, we define what kind of operation an object can perform. These
operations are defined by the classes that implement the Interface.

Interfaces form a contract between the class and the outside world, and this contract is
enforced at build time by the compiler.

You cannot instantiate them, and they may contain a mix of methods declared with or
without an implementation. All methods in interfaces are automatically public and abstract.

An interface can extend another interface.

Interfaces are more flexible and can deal with a lot more stress on the design of your program
than the implementation.

By introducing interfaces into your program, you are really introducing points of variation
at which you can plug in different implementations for that interface. An interface
primary purpose is abstraction, decoupling the "what" from the "how".

Note: since java 8 interfaces can contain default methods. In other words methods with implementation.
The keyword default is used (mostly for backwrds compatibility),
and static methods as well before Java 8 that not possible.

Note: Since java 9 and interface can also contain private methods (commonly used when 
two default methods in an interface share common code)

- Use an interface when..
You expect that unrelated classes will implement your interface. For example, the
interfaces Comparable and Cloneable are implemented by many unrelated clases.

You want to specify the behavior of a particular data type, but you are not concerned
about who implements its behaviour.

You want to separate different behaviour.

The Collections API is an excellent example, we have the List interface and
implementations ArrayList and LinkedList (more on that later in the course).

The JDBC API is another excellent example. It exist of almost only interfaces. The
concrete implementatiors are provided as "JDBC drivers". This enables you to write all
the JDBC code independent of the database (DB) vendor. You will learn more about
JDBC later in the course.

-- Java naming conventions

The things you will name in java are

- Packages
- Classes
- Interfaces
- Methods
- Constants
- Variables
- Type parameters

-- packages
    - Always lower case
    - Package names should be unique
    - Use your internet domain name, reversed, as a prefix for the package name
    - Oracle specify a convention for packge name at
    https://docs.oracle.com/javase/specs/jls/se6/html/packages.html#7

    Invalid domain name components
        - Replace invalid characters (i.e. -) in domain name with an underscore
        - Domain name components starting with a number should instead start with an underscore
        - Domain name components that are java keywords should have that component start with an underscore
    examples:
        - switch.supplier.com -> com.supplier._switch
        - 1world.com -> com._1world
        - experts-exchange.com -> com.experts_exchange
example packages names:
    - java.lang
    - java.io
    - org.xml.sax.helpers
    - com.timbuchalka.autoboxing

-- Class names
    - CamelCase
    - Class names should be nouns (they represent things)
    - Should start with a capital letter
    - Each word in the nme should also start with a capital (e.g. LinkedList)

    examples:
        - ArrayList
        - LinkedList
        - String
        - TopSong
        - GearBox
        - Main

-- Interface names
    - Capitalized like class names (CamelCase)
    - Consider what objects implementing the interface will become of what they will be able to do.

    examples:
        - List
        - Comparable
        - Serializable

-- Method names
    - mixedCase
    - Often verbs
    - Reflec the function performed or the result returned

    examples:
        - size()
        - getName()
        - addPlayer()

-- Constants
    - ALL UPPER_CASE
    - Separate words with underscore _.
    - Declared using the final keyword

    examples:
        - Static final int MAX_INT
        - Static final short SEVERITY_ERROR
        - Static final dobule P1 = 3.141592653

-- Variable names
    - mixedCase
    - Meaningful and indicative
    - Start with lower case letter
    - Do not use underscores
    
    examples:
        - i
        - league
        - SydneySwans
        - BoxLength

-- Type parameters
    - Single Character, capital letters
    - Guidelines given at https://docs.oracle.com/javase/tutorial/java/generics/types.html

    examples:
    - E - Element (ysed extensively by the java Collections Framework)
    - K - Key
    - T - Type
    - V - Value
    - S, U, V, etc, 2nd, 3rd, 4th types

-- create JAR and import library in intellij
    - create JAR
        - File > project structure > Artifacts > add (+) > JAR > from modules with dependencies.. > select [extract to the target JAR]
        - Build > build artifacts
    - import JAR
        - File > project structure > Libraries > add (+) > Java > select file from file system

-- Access modifiers

-- Top level
Only classes, interfaces and  can exist at the top level, everything else mus be included within one of these-

public: the object is visible to all classes everywhere, whether they are in the same package
or have imported the package containing the public class.

package-private: the object is only available within its own package (and isvisible to every class within the same package).
Package-private is specified by not specifying, i.e it is  the default if you do not specify public. There is not a
"package-private" keyword.

-- Member level

public: at the member level, public has the same meaning as at top level. A public class
member (or field) and public method can be accessed from any other class anywhere, even in a different package.

Package-private: this also has the same meaning as it does at the top level. An object
with no access modifier is visible to every class within the same package (but not to classes in external packages).

private: the object is only visible within the class it is declared. It is not visible anywhere else (including in subclasses of its class)

protected: the object is visible anywhere in its own package (like package-private) but also in sublcasses even if they are in another package.

// the final class prevents this class to be extended by other classes
public final class Math {

    /*
    * Don't let anyone instantiate this class
    */
    private Math() {}
}

// Collections Framework

Theatre theatre = new Theatre("Olympian", 8, 12);
List<Theatre.Seat> seatCopy = new ArrayList<>(theatre.seats); // shallow copy

Collections.reverse(seatCopy)
Collections.shuffle(seatCopy)
Collections.binarySearch(seats, requestedSeat, null); -> list, key, order defined by comparator c

Theatre.Seat minSeat = Collections.min(SeatCopy);
Theatre.Seat maxSeat = Collections.min(SeatCopy);

-- Maps
--
Map<String, String> languages = new HashMap<>();
languages.put("Java", "a compiled high level, object-orientated, platform independent language");
languages.put("Python", "an interpreted, object-oriented, high-level programming language with dynamic semantics");
languages.put("Algol", "an algorithmic language");
languages.put("BASIC", "Beginners All Purposes Symbolic Instruction Code");
languages.put("Lisp", "Therein lies madness");

System.out.println(languages.get("Java"));
--

get keys from map -> exits.keySet()
section 11 Adventure -> examples

-- Immutable classes -> make a class in such a way that it can't be modified after creation

-- HashSet -> to implement correctly, overriding the equals and hashCode functions is necessary
-- intellij -> Ctrl + o -> override methods
@Override -> makes it so the compiler checks if you are using the right signature, otherwise you are overloading and not overriding the function

-- Collections
Collection
  - Set
    - SortedSet
  - List
  - Queue
  - Deque

Map
  - SortedMap

-- Copy list
List<Theatre.Seat> seatCopy = new ArrayList<>(theatre.seats); // shallow copy 

-- Map
// print all the values of a Map
for (String key : languages.keySet()) {
    System.out.println(key + " : " + languages.get(key));
}

languages.remove("Lisp"); // remove element from map
// remove only if key/value pair match
if (languages.remove("Algol", "a family of algorithmic languages")) {
    System.out.println("Algol Removed");
} else {
    System.out.println("Algol not removed, key/value pair not found");
}

// string split method
String[] road = "You are standing at the end of a road before a small brick building".split("");
for (String i : road) {
     System.out.println(i);
}

// HashSet
-- override default equals method
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }

    System.out.println("obj.getClass() is " + obj.getClass());
    System.out.println("this.getClass() is " + this.getClass());
    if (obj == null || (obj.getClass() != this.getClass())) {
        return false;
    }
    String objName = ((HeavenlyBody) obj).getName();
    return this.name.equals(objName);
}

-- set interface bulk operations
s1.containsAll(s2);
s1.addAll(s2);
s1.retainAlll(s2);
s1.removeAll(s2);

note: all bulk operations are destructive. Therefore creating a new set from the existing ones is a good idea.

-- declaring an enum
public enum BodyTypes {
    START,
    PLANET,
    DWARF_PLANET,
    MOON,
    COMET,
    ASTEROID
}

-- loop through a HashSet
@Override
public String toString() {
    String s = "\nStock List\n";
    double totalCost = 0.0;
    for (Map.Entry<String, StockItem> item : list.entrySet()) {
        StockItem stockItem = item.getValue();
        double itemValue = stockItem.getPrice() * stockItem.getQuantityInStock();
        s = s + stockItem + ". There are " + stockItem.getQuantityInStock() + "in stock. Value of items: " + itemValue;
        s = s + itemValue + "\n";
        totalCost += itemValue;
    }
    return s + "Total stock value " + totalCost;
}

-- set up javafx
    - downlaod from: https://gluonhq.com/products/javafx/
    - extract the contents in a location (javafx-sdk-11.0.2)
    - in the welcome window of intellij > configure > structure for new projects
    - in the emerging window, select "global libraries" in the left side of the window
    - click the "+" (add) icon and select "java"
    - navigate to the folder that you just extracted and withing the lib folder, select all the .jar fields

-- create your first javafx application
    - from the intellij welcome window select the "+ create new project" option
    - in the new project window select the "java fx" option in the left panel
    - continue creating the project as you would normally
    - when the editor is initialited you will find some errors, these occur because
    javafx is no longer part of the default java jdk, because of this we have to configure it first
    - these steps need to be followed EVERYTIME you want to use javafx in a new project
    - right click the project folder in the left panel and select the "Open module settings" (F4) option
    - in the project settings > project
    - make sure that the project language level is the same as the project sdk.
    - in the module section, make sure is the same version as well.
    - in the platform settings > global libraries option
    - right click the javafx library and select the "add to modules.." option
    - confirm you want to add the libraries to the project.
    - if you try to run the application at this point you will get an error.
    "javafx runtime components are missing"
    - right click the src folder of the project > new
    - select module-info.java
    - in the newly created module-info.java file, add the following content.
... start:javafx001
module HelloWorldFx {
    requires javafx.fxml;
    requires javafx.controls;

    opens sample;
}
... end:javafx001
    - add this point you should be able to run the application successfully

-- java fx overview
Javafx was designed with the MVC, or model-view-controller pattern in mind. In a
nutshell, this pattern keeps the code that handles an application's data separate from the
UI code.

Because of this, when we're using the MVC pattern, we wouldn't mix the code that deals
with the UI and the code taht manipulates the application data in the same class. The
controller is sort of the middleman between the UI and the data.

When working with javafx, the model corresponds to the application's data model, the
view is the fxml, and the controller is the code tha determines what happens when a
user interacts with the UI. Essentially the controller handles events, which we'll cover in a
letter lesson.

-- setting default javafx window manually
GridPane root = new GridPane();
root.setAlignment(Pos.CENTER);
root.setVgap(10);
root.setHgap(10);
Label greeting = new Label("Welcome to javafx!");
greeting.setTextFill(Color.GREEN);
greeting.setFont(Font.font("Times New Roman", FontWeight.BOLD, 70));
root.getChildren().add(greeting);
primaryStage.setTitle("Hello JavaFX!");
primaryStage.setScene(new Scene(root, 1000, 275));
primaryStage.show();

-- using java fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.GridPane?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.text.Font?>
<GridPane fx:controller="sample.Controller"
          xmlns:fx="http://javafx.com/fxml" alignment="center" hgap="10" vgap="10">
    <Label text="Welcome to javafx!" textFill="green">
        <font>
            <Font name="Time New Roman bold" size="70"></Font>
        </font>
    </Label>
</GridPane>

-- javafx layouts google docs: https://docs.google.com/document/d/1erZfwwD0KGJieC-GMo38VRjttDtMej7dWcs9314NV9M
- Gridpane
    children overlap over the defaul position (row: 0, col:0), this is why we have to give them positions

-- download java look and feel graphic repository
download link: https://www.oracle.com/technetwork/java/repository-140393.html
    - unzip the .zip you need the .jar
    - in the project go to the project folder > open module settings (F4)
    - in the dependencies tab, selected the + symbol
    - seelct 1 jar or directories
    - go to the unzipped jar and selected
    - in the "choose categories of selected files", choose Classes
    - REMEMBER to add the new library to the module-info.java file
---
module Controls {
    requires javafx.fxml;
    requires javafx.controls;
    requires jlfgr;

    opens sample;
}
---

-- halt program execution
try {
    Thread.sleep(10000);
} catch(InterruptedException event) {
    // we don't care about this
}

-- todo list app
    - when editing name of files you might need to configure the main class name, top right of the IDE "Main" > "edit configurations..."
    - left bar > Application > Main > in the Main class field set "com.beltranbot.todolist.Main"

-- StringBuilder usage
StringBuilder stringBuilder = new StringBuilder(item.getDetails());
stringBuilder.append("\n\n\n\n");
stringBuilder.append("Due: ");
stringBuilder.append(item.getDeadline().toString());
itemDetailsTextArea.setText(stringBuilder.toString());

-- add change listener
todoListView.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<TodoItem>() {
    @Override
    public void changed(ObservableValue<? extends TodoItem> observableValue, TodoItem oldValue, TodoItem newValue) {
        if (newValue != null) {
            TodoItem item = todoListView.getSelectionModel().getSelectedItem();
            itemDetailsTextArea.setText(item.getDetails());
            deadLineLabel.setText(item.getDeadline().toString());
        }
    }
});

-- DateTimeFormatter usage
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("MMMM d, yyyy");
deadLineLabel.setText(dateTimeFormatter.format(item.getDeadline()));

-- string formatting
String.format(
        "%s\t%s\t%s",
        todoItem.getShortDescription(),
        todoItem.getDetails(),
        todoItem.getDeadline().toString()
);

-- for io operations
import javal.io.BufferedReader;
import javal.io.BufferedWriter;
import java.io.IOException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

-- for date operations
import java.time.LocalDate;
import java.time.format.DeateTimeFormatter;

-- write to a file (throws IOException)
Path path = Paths.get(filename);
BufferedWriter bufferedWriter = Files.newBufferedWriter(path);
try {
    bufferedWriter.write("text");
    bufferedWriter.newLine(); 
} finally {
    if (bufferedWriter != null) {
        bufferedWriter.close();
    }
}

-- read from a file (throws IOException)
Path path = Paths.get(filename);
BufferedReader bufferedReader = Files.newBufferedReader(path);

String input;
try {
    while ((input = bufferedReader.readLine()) != null) {
        System.out.println(input);
    }
} finally {
    if (bufferedReader != null) {
        bufferedReader.close();
    }
}


-- parse string to date
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("dd-MM-yyyy");
LocalDate date = LocalDate.parse(dateString, dateTimeFormatter);

-- get month
import java.time.Month;
Month.JULY;

--- get current date
LocalDate.now()

-- file chooser in javafx
FileChooser chooser = new FileChooser();
chooser.showOpenDialog(gridPane.getScene().getWindow()); // pass the window to prevent opening multiple file choosers

-- directory chooser in javafx
DirectoryChooser chooser = new DirectoryChooser();
File file = chooser.showDialog(gridPane.getScene().getWindow());
if (file != null) {
    System.out.println(file.getPath());
} else {
    System.out.println("Chooser was cancelled");
}

-- save file and filters
FileChooser chooser = new FileChooser();
chooser.setTitle("Save application file");
chooser.getExtensionFilters().addAll(
    new FileChooser.ExtensionFilter("Text", "*.txt"),
    new FileChooser.ExtensionFilter("PDF", "*.pdf"),
    new FileChooser.ExtensionFilter("Image Files", "*.jpg", "*.png", "*.gif"),
    new FileChooser.ExtensionFilter("All types", "*.*")
);
File file = chooser.showSaveDialog(gridPane.getScene().getWindow());
if (file != null) {
    System.out.println(file.getPath());
} else {
    System.out.println("Chooser was cancelled");
}

-- choose multiple dialog
FileChooser chooser = new FileChooser();
chooser.setTitle("Save application file");
chooser.getExtensionFilters().addAll(
    new FileChooser.ExtensionFilter("Text", "*.txt"),
    new FileChooser.ExtensionFilter("PDF", "*.pdf"),
    new FileChooser.ExtensionFilter("Image Files", "*.jpg", "*.png", "*.gif"),
    new FileChooser.ExtensionFilter("All types", "*.*")
);
List<File> files = chooser.showOpenMultipleDialog(gridPane.getScene().getWindow());
if (files != null) {
    for(File file : files) {
        System.out.println(file.getPath());
    }
} else {
    System.out.println("Chooser was cancelled");
}

-- open web browser from java fx
-> note:
/* mind the module-info.java
module JavaFXApplication {

    requires javafx.fxml;
    requires javafx.controls;
    requires javafx.web;
    requires java.desktop;

    opens sample;
}
*/
String osName = System.getProperty("os.name");
String urlString = "http://www.javafx.com";

try {
    if (osName.equals("Linux")) {
        if (Runtime.getRuntime().exec(new String[]{"which", "xdg-open"}).getInputStream().read() != -1) {
            Runtime.getRuntime().exec(new String[]{"xdg-open", urlString});
        }
    } else {
        Desktop.getDesktop().browse(new URI(urlString));
    }
} catch (IOException ioException) {
    ioException.printStackTrace();
} catch (URISyntaxException uriSyntaxException) {
    uriSyntaxException.printStackTrace();
}

-- open url in webview
WebEngine webEngine = webView.getEngine();
webEngine.load(urlString);

-- install scene builder
    - donwload installer from https://gluonhq.com/products/scene-builder/
    - in the welcome window of intellij got to configure > settings > languages and frameworks
    - select javafx and then choose the route of the SceneBuilder location (/opt/SceneBuilder/SceneBuilder)

-- java fx challenge
For this challenge, you'll create a simple contacts application that has a single main window.
the application will allow the user to add a contact, edit a contact, and delete a contact.
You'll display the contacts using the TableView control.

-- module-info.java
module JavaFxChalenge {

    requires javafx.fxml;
    requires javafx.controls;
    requires java.xml;

    opens sample;
    exports datamodel;
}

-- basic input & output including java.util
-- exceptions

LBYL -> look before you leave
EAFP -> easier to ask for forgiveness than permission

Exception: an events that occur during the excecution of a program that prevents the normal flow of the program instructions.

-- throw custom exception messages
throw new ArithmeticException("attempt to divide by zero");

-- check for multiple exceptions
try {
    int result = divide();
    System.out.println(result);
} catch (NoSuchElementException | ArithmeticException exception) {
    System.out.println(exception.toString());
    System.out.println("Unable to perform division, autopilot shitting down");
}

-- write to a file
public static void main (String[] args) {
    FileWriter locationsFile = null;
    try {
        locationsFile = new FileWriter("location.txt");
        for (Location location : locations.values()) {
            locationsFile.write(location.getLocationID() + "," + location.getDescription() + "\n");
        }
    } catch (IOException ioException) {
        System.out.println("in catch block");
        ioException.printStackTrace();
    } finally {
        try {
            if (locationsFile != null) {
                locationsFile.close();
            }
        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
    }
}

-- try with resources, writing files
try (FileWriter locationsFile = new FileWriter("locations.txt")) {
    for (Location location : locations.values()) {
        locationsFile.write(location.getLocationID() + "," + location.getDescription() + "\n");
    }
}

-- writing to multiple files with try with resources
try (
        FileWriter locationsFile = new FileWriter("locations.txt");
        FileWriter dirFile = new FileWriter("directions.txt");
) {
    for (Location location : locations.values()) {
        locationsFile.write(location.getLocationID() + "," + location.getDescription() + "\n");
        for (String direction : location.getExits().keySet()) {
            dirFile.write(location.getLocationID() + "," + direction + "," + location.getExits().get(direction) + "\n");
        }
    }
}

-- reading from a file
Scanner scanner = null;
try {
    scanner = new Scanner(new FileReader("locations.txt"));
    scanner.useDelimiter(",");
    while (scanner.hasNext()) {
        int location = scanner.nextInt();
        scanner.skip(scanner.delimiter());
        String description = scanner.nextLine();
        System.out.println("imported location: " + location + ": " + description);
        Map<String, Integer> tempExit = new HashMap<>();
        locations.put(location, new Location(location, description, tempExit));
    }
} catch (IOException ioException) {
    ioException.printStackTrace();
} finally {
    if (scanner != null) {
        scanner.close();
    }
}

-- using buffered BufferedReader
try {
    scanner = new Scanner(new BufferedReader(new FileReader("directions.txt")));
    scanner.useDelimiter(",");
    while (scanner.hasNextLine()) {

        String input = scanner.nextLine();
        String[] data = input.split(",");
        int loc = Integer.parseInt(data[0]);
        String direction = data[1];
        int destination = Integer.parseInt(data[2]);
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(loc);
        stringBuilder.append(": ");
        stringBuilder.append(direction);
        stringBuilder.append(": ");
        stringBuilder.append(destination);
        System.out.println(stringBuilder);
        Location location = locations.get(loc);
        location.addExit(direction, destination);
    }
} catch (IOException ioException) {
    ioException.printStackTrace();
} finally {
    if (scanner != null) {
        scanner.close();
    }
}

-- reading files with try with resources
static {
    try (Scanner scanner = new Scanner(new FileReader("locations_big.txt"))) {
        scanner.useDelimiter(",");
        while (scanner.hasNext()) {
            int location = scanner.nextInt();
            scanner.skip(scanner.delimiter());
            String description = scanner.nextLine();
            System.out.println("imported location: " + location + ": " + description);
            Map<String, Integer> tempExit = new HashMap<>();
            locations.put(location, new Location(location, description, tempExit));
        }
    } catch (IOException ioException) {
        ioException.printStackTrace();
    }

    // now read the exits

    try (BufferedReader bufferedReader = new BufferedReader(new FileReader("directions_big.txt"))) {
        String input;
        while ((input = bufferedReader.readLine()) != null) {
            String[] data = input.split(",");
            int loc = Integer.parseInt(data[0]);
            String direction = data[1];
            int destination = Integer.parseInt(data[2]);
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(loc);
            stringBuilder.append(": ");
            stringBuilder.append(direction);
            stringBuilder.append(": ");
            stringBuilder.append(destination);
            System.out.println(stringBuilder);
            Location location = locations.get(loc);
            location.addExit(direction, destination);
        }
    } catch (IOException ioException) {
        ioException.printStackTrace();
    }
}

-- java new I/O - Overview
in java 1.4, a new I/O package was added to the java SDK

called java.nio, the package was described as an improvement to Java I/O because the classes in the
package perform I/O in a non-blocking manner. java.nio was also meant to fix some of the problems
developers could run into when using the java.io classes to work with the file system.

The java.nio classes fall into one of two buckets: those that deal with the file system, and those that deal
with reading and writing data. In this video, we'll start looking at the classess that read data from, and
write data to, a datasource.

when using classes in the java.io package, a thread will block while it's waiting to read or write to a
stream or buffer.

However, threads using the java.nio classes will not block. They are free to continue executing, so
java.nio was introduced as a performance improvement.

However, many develolpers have argued that the java.nio package was a step backwards. Some have
shown that blocking I/O is often faster than non-blocking I/O.

* Threads, blocking, etc is covered in the Threads section of the course.

Also, working with the java.nio classes is more complex, as you'll see. As has happened with other
additions to the java language, many developers still prefer to write code using the older java.io classes,
and you may decide to do that too, but it's important to understand the new way of doing I/O, in case
you're ever asked to work with code that uses it.

Previously, you learned that the java.io classes work with streams (character and binary). Data is read
one byte or character at a time and sometimes buffered, depending on which classes are used. When
using java.nio, you'll deal with data in blocks, and rather than processing one byte or character at a
time, one block will be processed at a time. To accomplish this, you'll use channels and buffers, which
you'll see later in later videos.

Having said all that about java.nio, you can use java.nio methods to create a java.io stream.

Make a copy of the adventure game project that we last used to read and write the data as an object
stream e.g. Before we looked into Random access. You can grab a zip file from the resources section
of this video.


-- Filesystem

So far, you've learned how to create, read, and write files and datasources using java.nio.
Sometimes, you don't want to read from a file or write to a file. You want to copy files,
delete files, move them, etc. In other words, you want to work with the file system. Java.nio
has you covered. In fact, it has a whole package dedicated to working with the file system,
called java.nio.file.

We'll start by taking a look at the Path interface, which is what you'll use to identify a file
on the file sytem. You've already used Paths. You created them when you wanted to use
java.io classes to read and write files, but you called a method such as
Files.newBufferedWriter() so that the BufferedWriter would be backed by a java.nio buffer
and channel.

But what is a path? Well, you're familiar wit hthe concept of a file path because you use
them all the time. If you open the File Explorer on your system, you'll see a bunch of root
folders (usually hard drives, peripheral drives like DVD or Blu-ray drivers, external drives, thumb drives, etc.)
Each of those top-level drives is a root node in a path. For exmaple, the
directory C:\ is the root  node for the C drive.

Each folder, which is also referred to as a directory, is also a node in a path. And then, of
course, there's the file itself. If you have downloaded a file and placed it in the
C:\downloads directory, then the file path has three nodes: One for C:\, one for the
downloads directory, and one for the file.

This path is unique. Youcan't have two files with the same name in the same directory,
because each file is identified by its path. For the downloads example, if you named the 
file you downloaded data.txt, then the path would be C:\downloads\file.txt. You
wouldn't be able to place a second file called file.txt into the same directory.

The character used to separate the directory anmes in a path is called the delimiter, and it
can differ between operating systems. For example, for Windows, the delimiter is the
backslash ('\'). On Unix, the delimiter is the forward slash('/').

Everything we discuss about paths applies to files and directories. To keep things
simple, we won't walways refer to both. But you can create a path for a file or directory.
Sometimes it won't make sense to use a path to a directory, for example, when you want
to create a file. Other times it will only make sense to use a path to a directory. It will
depend on what you want todo. Just keep in mind that pahts can refer to either.

File paths can be absolute or relative. The path C:\downloads\file.txt is and absolute path,
because it starts at a root node. The path photos\vacation\mountain.jpg is a relative path
because it doesn't specify a root node, it doesn't contain enough information to identify
the file. It would have to be combine with another path that does contain a root node.

When using relative paths in applications, ther's usually the concept of a current or
working directory that you can combine with relative paths. For exapmle, when you were 
running applications that used Path, you didn't specify the entiry Path. You did
something like the following:

-- relative path
Path dataPath = FileSytems.getDefault().getPath("data.txt");

The string "data.txt" doesn't give enough information about where the file is located. But
you'll notice that you're calling FileSystems.getDefault() first, and then getPath(). What's
happening is that the getDefault() call returns a FileSystem object with a working directory
set to the current user directory.

When running an application from within IDEA, the current user directory is the IDEA
project directory, and so that's the working directory for the FileSystem object. The
working directory is then combined with the Path you passed to the getPath() call, and
that's why the files are created in the IDEA project's directory.

Instead, you could have done something like the following:
-- use absolute path
Path dataPath = Paths.get("C:\\MyIdeaProject\\Projects1\\data.txt;

Notice that you're using the Paths class (which has an 's' at the end) when you call the get()
method. There are only two methods in the class, and both of them return a Path based
on a string.

Let's jump into and IDEA project now, so you can play around with paths a bit.

-- Paths
Now that you have an idea of how to build paths to files in the current directory, in a path
relative to another directory, or to anywhere on the file system using an absolute paht,
let's briefly discuss why the Path interface came about. The java.io.File clas also points to
files on the file sytem. Why did the Java developers introduce another class that does the
same thing in java 7? The File class, while useful, has a few problems. What are those
problems?
    - Many methods in the class don't throw exceptions, or don't provide specific error
    messages when they fail. One example would be the File.delete() method, which
    returns a boolean. If the deletion fails, you can't tell if it was because the file didn't
    exist, or the application didn't have permission to delete the file, or ...? Unfortunately,
    the method doesn't provide that information.
    - The File.rename() method works differently on different platforms. Java is supposed
    to be portable accross platforms, meaning the code shouldn't have to worry about
    which operating system it's running on.
    - There's no support for symbolic links. A symbolic link is a kind of file that points to
    another file. They're often used with networks, to point to a remote location. The File
    class doesn't understand them.
    - The File class doesn't provide a way to get metadata about a file, such as its
    permissions, its owner, and other security information. The metadata it does provide
    is retrieved inefficiently.
    - Many of the methods don't perform well when working with lots of data. For example,
    if you use the File class to request a list of all the files in a directory, and there are a lot
    of files, the method can hang.

try {

    // create file
    Path fileToCreate = FileSystems.getDefault().getPath("Examples", "file2.txt");
    Files.createFile(fileToCreate);

    // create directory
    Path dirToCreate = FileSystems.getDefault().getPath("Examples", "Dir4");
    Files.createDirectory(dirToCreate);

    // create directories
    Path dirToCreate = FileSystems.getDefault().getPath("Examples", "Dir2/Dir3/Dir4/Dir5/Dir6");
    Files.createDirectories(dirToCreate);

    // file attributes
    Path filePath = FileSystems.getDefault().getPath("Examples", "Dir1/file1.txt");
    long size = Files.size(filePath);
    System.out.println("Size = " + size);
    System.out.println("Last modified = " + Files.getLastModifiedTime(filePath));

    // BasicFileAttributes
    BasicFileAttributes attributes = Files.readAttributes(filePath, BasicFileAttributes.class);
    System.out.println("Size = " + attributes.size());
    System.out.println("Last modified = " + attributes.lastModifiedTime());
    System.out.println("Created = " + attributes.creationTime());
    System.out.println("Is directory = " + attributes.isDirectory());
    System.out.println("Is regular file = " + attributes.isRegularFile());

    // Delete file
    Path fileToDelete = FileSystems.getDefault().getPath("Examples", "Dir1", "file1copy.txt");
    Files.deleteIfExists(fileToDelete);

    // rename file
    Path fileToMove = FileSystems.getDefault().getPath("Examples", "file1qqqq.txt");
    Path destination = FileSystems.getDefault().getPath("Examples", "file2.txt");
    Files.move(fileToMove, destination);

    // move file
    Path fileToMove = FileSystems.getDefault().getPath("Examples", "file1copy.txt");
    Path destination = FileSystems.getDefault().getPath("Examples", "Dir1", "file1copy.txt");
    Files.move(fileToMove, destination);

    // replace existing file
    Path sourceFile = FileSystems.getDefault().getPath("Examples", "file1.txt");
    Path copyFile = FileSystems.getDefault().getPath("Examples", "file1copy.txt");
    Files.copy(sourceFile, copyFile, StandardCopyOption.REPLACE_EXISTING);

    // copy file
    sourceFile = FileSystems.getDefault().getPath("Examples", "Dir1");
    copyFile = FileSystems.getDefault().getPath("Examples", "Dir4");
    Files.copy(sourceFile, copyFile, StandardCopyOption.REPLACE_EXISTING);

} catch(IOException e) {
    e.printStackTrace();
    System.out.println(e.getMessage());
}

// directories
// glob
// read existing directory contents
The * character matches any string (which can contain any number of characters).

*.dat will match any path with the .dat extension

*.{dat,txt} will match any path that has the extension .dat or .txt

? matches exactly one character. For example, the glob ??? would match any path that contains exactly
three characters

myFile* matches any paths that begin with myFile.
b?*.txt matches any paths that are at least two characters long and begin with the chracter b (the ?
forces a second character, and the * mataches 0 or more characters).

// list all contents of a directory
Path directory = FileSystems.getDefault().getPath("FileTree/Dir2");
try (DirectoryStream<Path> contents = Files.newDirectoryStream(directory)) {
    for (Path file : contents) {
        System.out.println(file.getFileName());
    }
} catch(IOException | DirectoryIteratorException e) {
    System.out.println(e.getMessage());
}

// using glob to filter
Path directory = FileSystems.getDefault().getPath("FileTree/Dir2");
try (DirectoryStream<Path> contents = Files.newDirectoryStream(directory, "*.dat")) {
    for (Path file : contents) {
        System.out.println(file.getFileName());
    }
} catch(IOException | DirectoryIteratorException e) {
    System.out.println(e.getMessage());
}

// list only files
DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() {
    public boolean accept(Path path) throws IOException {
        return Files.isRegularFile(path);
    }
};

// DirectoryStream.Filter<Path> filter = p -> Files.isRegularFile(p); // with lambda expression

Path directory = FileSystems.getDefault().getPath("FileTree/Dir2");
try (DirectoryStream<Path> contents = Files.newDirectoryStream(directory, filter)) {
    for (Path file : contents) {
        System.out.println(file.getFileName());
    }
} catch(IOException | DirectoryIteratorException e) {
    System.out.println(e.getMessage());
}

// get system directory separator
String separator = File.separator;
System.out.println(separator);
separator = FileSystems.getDefault().getSeparator();
System.out.println(separator);

// create temporary file
try {
    Path tempFile = Files.createTempFile("myapp", "appext");
    System.out.println("temporary file path = " + tempFile.toAbsolutePath());
} catch (IOException e) {
    System.out.println(e.getMessage());
}

// get file stores
Iterable<FileStore> stores = FileSystems.getDefault().getFileStores();
for (FileStore store : stores) {
    System.out.println("volume name / drive letter = " + store);
    System.out.println("file store =" + store.name());
}

// get root directories
Iterable<Path> rootPaths = FileSystems.getDefault().getRootDirectories();
for (Path path : rootPaths) {
    System.out.println(path);
}